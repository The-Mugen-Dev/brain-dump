{
    "componentChunkName": "component---node-modules-gatsby-theme-code-notes-src-templates-note-js",
    "path": "/algo-practice",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Algorithm Practice Solutions\",\n  \"emoji\": \"ðŸ’¡\",\n  \"created\": \"2022-10-08T00:00:00.000Z\",\n  \"modified\": \"2022-10-08T00:00:00.000Z\",\n  \"tags\": [\"leetcode\", \"data-structures\", \"interview\"],\n  \"link\": \"https://www.techinterviewhandbook.org/grind75\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"twosum\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/two-sum/\"\n  }, \"twoSum\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"/*\\nBefore coding:\\n   - only integer numbers? or negative values?\\n\\nApproaches\\n   - Brute force:\\n  - Iterate over all element and create all two number permutation possible\\n  - Make the sum of the pair numbers\\n  - Go through the result and check against the target\\n   - Map solution\\n  - Check length of arr for possible break conditions:\\n   - if less than 2 nums solution is not possible\\n   - if 2 return as result, problem states that we have at least one result\\n  - Create a map with all the numbers in the array fast lookups\\n   - key: value of the array (we use the value to subtract the value and find out if this number  will sum up to our target)\\n   - value: index in the array (keep track of the index position to return it as the result)\\n  - Go again through each element\\n   - subtract from target your current number\\n   - check if the result of the subtraction is in our map\\n   - if true\\n  - Create a pair using our current index and the value in our map\\n\\n*/\\nvar twoSum = function(nums, target) {\\n\\n    if(nums.length < 2) return false;\\n    if(nums.length === 2) return [0,1];\\n\\n    const map = {};\\n    for(const numIndex in nums){\\n        map[nums[numIndex]] = numIndex;\\n    }\\n\\n    for(const numIndex in nums){\\n        const num = nums[numIndex];\\n        const diff = target - num; //What number we need to sum in order to get to the target\\n        const indexOfDiff = map[diff]; //Get the index to make sure we don't use the same number twice\\n        if(map[diff] && indexOfDiff !== numIndex){\\n            return [numIndex,map[diff]]\\n        }\\n    }\\n};\\n\\n\")), mdx(\"h3\", {\n    \"id\": \"valid-parentheses\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/valid-parentheses/\"\n  }, \"Valid Parentheses\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"/**\\n * @param {string} s\\n * @return {boolean}\\n * - Check the length of the input, if is odd return false, only even number can return true\\n * - A stack can help us to keep track of the order of each opening a closing elements\\n * - Opening set, this will help us to do quick lockups to check if we need to push\\n * element into the stack.\\n * - Iterate through the elems, if the element is opening push it\\n * - If the element is closing, pop the top of the stack\\n *   and check if the current element it's the matching pair of the current element\\n * - Make sure that there are not left elements in the stack\\n */\\nvar isValid = function(s) {\\n    \\n    if(s.length % 2 !== 0) return false;\\n    \\n    const opening = new Set(['[','{','(']);\\n    const matching = {\\n        ']':'[',\\n        '}':'{',\\n        ')':'('\\n    };\\n    \\n    let stack = []; \\n    \\n    for(const elm of s){\\n        if(opening.has(elm)){\\n            stack.push(elm);\\n            continue;\\n        }\\n        if(matching[elm] !== stack.pop()) return false;\\n    }\\n    return stack.length === 0;\\n};\\n\")), mdx(\"h3\", {\n    \"id\": \"merge-two-sorted-list\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/merge-two-sorted-lists/\"\n  }, \"Merge Two Sorted List\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} list1\\n * @param {ListNode} list2\\n * @return {ListNode}\\n *\\n * Iterate thorugh the list until we finish one of them\\n * - Find the smallest of the current element of the two list and\\n *   push it to the result list\\n * - If we finish one of the list, append the other ones since the lists\\n *   are in order\\n */\\nvar mergeTwoLists = function(list1, list2) {\\n\\n    let list = new ListNode();\\n    let head = list;\\n    while(list1 && list2){\\n        if(list1.val < list2.val){\\n            list.next = new ListNode(list1.val);\\n            list1 = list1.next;\\n        } else {\\n            list.next = new ListNode(list2.val);\\n            list2 = list2.next;\\n        }\\n        list = list.next;\\n    }\\n\\n    if(list1){\\n        list.next = list1;\\n    } else {\\n        list.next = list2;\\n    }\\n    return head.next;\\n};\\n\")), mdx(\"h3\", {\n    \"id\": \"is-palindrome\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/valid-palindrome\"\n  }, \"Is Palindrome\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function (s) {\\n    const filterInvalidCharacters = (str) => {\\n        return s.toLowerCase()\\n            .split('')\\n            .filter(c => c >= 'a' && c <= 'z' || c >= '0' && c <= '9')\\n    }\\n    const filteredPhrase = filterInvalidCharacters(s);\\n    const phraseLength = filteredPhrase.length - 1;\\n    \\n    /*\\n        Helper pointer while comparing the letters\\n        - Position them at the start and end of the word/phrase\\n    */\\n    let left = 0;\\n    let right = phraseLength;\\n    \\n    //Iterate until the middle of the phrase\\n    for (let i = 0; i < phraseLength / 2; i++, left++, right--) {\\n        if (left > right) return true;\\n        if (filteredPhrase[left] !== filteredPhrase[right]) return false;\\n    }\\n    return true;\\n};\\n\")), mdx(\"h3\", {\n    \"id\": \"invert-a-binary-tree\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://leetcode.com/problems/invert-binary-tree\"\n  }, \"Invert a Binary Tree\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n * Solution\\n * - Do a BFS Traversal\\n *  - Validate input, make sure is not invalid\\n *  - For each node move left child node to right and right to left\\n *  - Push existen child node to the queue for the BFS traversal\\n */\\nvar invertTree = function(root) {\\n    \\n    if(!root) return root;\\n    const head = root;\\n    const queue = [root];\\n    \\n    while(queue.length > 0){\\n        let current = queue.shift();\\n        let tmp = current.left;\\n        current.left = current.right;\\n        current.right = tmp;\\n        \\n        if(current.left) queue.push(current.left);\\n        if(current.right) queue.push(current.right);        \\n    }\\n    return head;\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode invertTree(TreeNode root) {\\n        \\n        if(root == null) return root;\\n        \\n        TreeNode head = root;\\n\\n        Queue<TreeNode> queue =  new LinkedList();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            TreeNode current =  queue.poll();\\n            \\n            TreeNode temp = current.left;\\n            current.left = current.right;\\n            current.right = temp;\\n            \\n            if(current.left != null) {\\n                queue.add(current.left);\\n            }\\n            \\n            if(current.right != null){\\n                queue.add(current.right);\\n            }\\n        }\\n        \\n        return head;\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Algorithm Practice Solutions","tags":["leetcode","data-structures","interview"],"emoji":"ðŸ’¡","link":"https://www.techinterviewhandbook.org/grind75","modified":"October 8, 2022","modifiedTimestamp":"2022-10-08T00:00:00.000Z"},"references":[],"fields":{"slug":"/algo-practice"},"tableOfContents":{"items":[{"url":"#twosum","title":"twoSum"},{"url":"#valid-parentheses","title":"Valid Parentheses"},{"url":"#merge-two-sorted-list","title":"Merge Two Sorted List"},{"url":"#is-palindrome","title":"Is Palindrome"},{"url":"#invert-a-binary-tree","title":"Invert a Binary Tree"}]},"parent":{"relativePath":"algo-practice.mdx"}}},"pageContext":{"id":"9b0426c0-120b-5b0a-8788-fc18b335e68b","previous":{"id":"c194f551-5998-5f42-a3a9-69d7a3d2038d","frontmatter":{"title":"Useful WebTools","tags":["tools"]},"fields":{"slug":"/dev-tools"}},"next":null,"hasUntagged":false,"basePath":"/","tags":[{"tag":"css","totalCount":1,"slug":"/css","path":"/tag/css"},{"tag":"data-structures","totalCount":1,"slug":"/data-structures","path":"/tag/data-structures"},{"tag":"interview","totalCount":2,"slug":"/interview","path":"/tag/interview"},{"tag":"leetcode","totalCount":1,"slug":"/leetcode","path":"/tag/leetcode"},{"tag":"setup","totalCount":1,"slug":"/setup","path":"/tag/setup"},{"tag":"tools","totalCount":1,"slug":"/tools","path":"/tag/tools"}]}},
    "staticQueryHashes": ["1308211557","2744905544","467212769"]}